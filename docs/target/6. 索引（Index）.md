# 6. 索引（Index）

## 6.1 索引目的

索引的主要目的在于提高查询效率。另外，InnoDB的行锁和间隙锁也是通过索引实现的。

## 6.2 索引类型

​	InnoDB表的索引从数据组织层面可分为两类：

1. **聚簇索引**（一般是主键索引）
2. **辅助索引**（二级索引）



从约束的层面分析，分为如下几类：

### 普通索引

​	普通索引（INDEX）：最基本的索引，它没有任何限制，用于加速查询。

```mysql
KEY `version` (`version`) USING BTREE
```

### 唯一索引

​	唯一索引（UNIQUE ）：索引列的值必须唯一，允许有空值。如果是组合索引，则列值的组合必须唯一。

```mysql
UNIQUE KEY `version` (`version`) USING BTREE
```

### 主键索引

​	主键索引（PRIMARY KEY）：一个表只能有一个主键（非空、唯一），可以是联合主键。一般是在建表的时候同时创建主键索引。

​	主键索引和加非空、唯一约束的索引有本质的区别：主键索引是聚簇索引，只是加了非空、唯一约束的索引是非聚簇索引（二级索引），二者组织数据的形式不同。

```mysql
PRIMARY KEY (`id`)
```

特别注意:

- 主键强烈推荐递增式的插入数据；
- 主键的长度不应过长，过长的主键会影响索引搜索效率，也会占用过多的磁盘空间；



### 组合索引

​	指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时要遵循**最左前缀匹配原则**。

```mysql
KEY `home` (`hometown`,`amount`) USING BTREE
```

​	组合索引可以是聚簇索引（联合主键），也可以是辅助索引（二级索引）。 

**最左前缀匹配原则**：

​	最左前缀匹配原则是数据库索引文件(B树索引)的特性，即最左边的值一定要确定下来，索引才能生效。最左原则的顺序不是指查询条件中的顺序, 而是创建的索引列顺序。

​	如上面的 key（(`hometown`,`amount`) ）这个组合索引，查询条件中一定要包含最左侧的 hometown 字段，才有可能使用索引查询，但是查询条件中的顺序是没有要求的，因为mysql优化器会对顺序进行优化。



在以下两个应用场景需要遵守：

1. 使用组合索引时，最左列的索引一定要用到（查询条件顺序无所谓）。
2. 右模糊查询（LIKE语句）才能使索引生效。左模糊和全模糊均不能使索引生效。



注意:

- 组合索引不满足最左前缀匹配原则, 不会使用索引。
- 组合索引的顺序非常重要。根据经验，应该把使用最频繁、区分度高的一列放在组合索引的最左边。
- 如果组合索引中第一个字段是范围查询需要单独建一个索引。
- 组合索引中包含的字段个数不应该太多，建议不要超过5个。



### 全文索引

全文索引（FULLTEXT）：对文本的内容进行分词，进行全文搜索。

```mysql
FULLTEXT KEY `home` (`hometown`)
```



### 限制索引长度

​	前面提到主键的长度不要过长，因为主键也是一个索引，而对于普通索引，如时间、字符串类型的列，也不应该过长。

#### 语法

```mysql
KEY `version` (`version`(16)) USING BTREE
```

上面的 `version` 列是字符类型的，创建索引，并且指定索引长度为16。

#### 优点

​	限制索引长度的优点是节省磁盘空间，不至于索引文件过大，提高数据插入效率。



#### 缺点

​	限制索引长度的缺点也不少，主要在于两点：

1. 如果对主键或唯一索引限制索引长度，那么插入唯一数据时，有可能会插入失败！原因很简单，长度是18的时候，数据是唯一的，那截取为16长度的时候，不能保证数据是唯一的，如果截取后的数据重复了，MySQL就会报错！
2. 使覆盖索引查询不再有效，如果查询的列中在索引中都可以找到，那么就不需要回表查询，大大提高查询效率，可当限制索引长度后，索引文件上的数据并不一定是全部的原表数据，而是截取后的部分数据，所以即便是按照覆盖索引查询的规范去写查询，也不会生效了，而是再回表查询原表数据，多了很多操作，降低了效率。



​	综上所述，限制索引长度虽然有优点，但弊端还是不容忽视的，如果想要限制索引长度，需慎重分析，然后考虑到底要不要限制。



## 6.3 查看索引

通过 `show index` 查看一张表的索引信息：

```mysql
SHOW INDEX FROM table_name;
```

输出:

<img src="https://gitee.com/Jackpotsss/pic_go/raw/master/img/image-20200303213104386.png" alt="image-20200303213104386" style="zoom:67%;" />

## 6.4索引优化

### 适用场景

​	B-Tree 索引适用于**键全值查询，键范围查询**和**键左前缀查询**。

1. 全键值匹配

   全键值匹配指的是和索引中的所有列进行匹配。例如是组合索引（name，age），就查找姓名为王三，年龄为25的人。

2. 匹配最左前缀

   只是用索引的第一列。例如是组合索引（name，age），只查找姓名为王三的人。

3. 匹配列前缀

   只匹配某一列的值的开头部分。例如查找姓王的所有人。（注意，左前缀必须明确，索引才有效！）

4. 匹配范围值

   例如对于单列索引（age），查找年龄在18~60岁之间的人。

5. 精确匹配某一列并范围匹配另一列

   例如查找名字为王三，年龄在18~60岁之间的人。

6. 只访问索引的查询（覆盖索引）

   B-Tree 索引支持“只访问索引的查询”，即查询只访问索引，不回表访问数据行。



### B-Tree 索引的限制

下面的场景全部都无法使索引生效：

1. 对于组合索引，如果查询条件**不包含**最左列索引，则无法使用索引。

2. **左模糊和全模糊**无法使用索引，对于匹配列前缀，左边部分的内容必须确定，即索引支持右模糊查询，但不支持左模糊和全模糊查询。
3. 如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。
4. 如果索引列是**运算表达式**的一部分，或是函数的参数，索引无效。
5. 数据出现**隐式类型转换**的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来。
6. 使用否定条件：`<> 或 !=、NOT IN、IS NOT NULL`，否定条件**通常**会使索引失效，从而进行全表扫描。



注：

​	场景一，对于组合索引（name，age），直接查找年龄在18~60岁之间的人，是全表扫描，不会使用索引。

​	场景三，右边的列指的是表定义结构中列的左右顺序，不是where 条件中的顺序。



下面是索引效率不高的应用场景：

1. 设置索引的列的区分度应该很高，即该列的值重复率不要太高，比如性别、状态之类的枚举类型，即便使用索引，效率提升也不大。




**适用范围**

- 对于很小的表，比如只有几十行或几百行数据，没必要使用索引，全表扫描更高效。
- 对于中到大型的表，索引就非常有效。
- 对于特大型的表，比如上千万条数据，使用索引的代价会越来越大，此时需要考虑使用分区或分表。



### 高性能索引策略



1. **符合最左前缀匹配原则【非常重要的原则】。**

   mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2. **尽量选择区分度高的列建立索引。**

   区分度也叫选择性、基数，唯一键的区分度是1，而一些状态、性别字段在大数据面前区分度近乎为0，区分度较小的键，索引效果较差；

   区分度的公式是 `count(distinct col)/count(*)` ；

3. **在varchar类型字段上建立索引时，必须指定索引长度；**

   长度和区分度之间做一个衡量即可。

4. **索引列不能参与计算，保持列“干净”。**

   比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引；同样的，where age +1 > 10也不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

5. **单张表的索引个数不要过多，一般建议不要超过5个。**

   索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
   
6. **组合索引中包含的字段数不要过多，一般建议不要超过5个。 ** 

7. **主键的插入一定是递增的。**（提高B+树数据结构的分页效率）

   


### B-Tree 索引的优点

​	索引可以让服务器快速的定位到表的指定位置，这是索引最主要的作用，但这不是索引唯一的作用，索引还有一些其他的附加作用。

​	B-Tree 索引是按照顺序存储数据，所以Mysql可以用来做 ORDER BY 和 GROUP BY 操作。因为数据是有序的，所以B-Tree 也就将相邻的列值都存储在一起。最后，因为索引存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。

​	据此特性，总结出索引有如下三个优点：

1. 索引大大减少了服务器需要扫描的数据量。
2. 索引可以帮助服务器避免排序和使用临时表。
3. 索引可以将随机I/O变为顺序I/O。



《阿里巴巴Java开发手册》索引规约

**【强制】**

1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。

   唯一索引会明显提高查询速度。

2. 【强制】在varchar字段上建立索引时，必须指定索引长度。

   没必要对全字段建立索引，根据实际文本的区分度决定索引长度即可。（一般字符串类型长度为20的索引，区分度高达90%以上）

3. 【强制】模糊搜索like 严禁左模糊或全模糊，使用右模糊。如果需要可以使用搜索引擎来解决。

   索引文件具有B树的最左前缀匹配特性，如果左边的值未确定，那么无法使用索引。

   同样的，使用组合索引时，最左边的列一定要使用到，否则索引无效。

4. 【强制】超过三个表禁止join。

   需要join的字段，类型必须绝对一致；
   当多表关联查询时，保证关联的字段需要有索引；



**【推荐】**

1. 【推荐】利用覆盖索引进行查询，避免回表。

   覆盖索引指的是如果一个索引包含了所有需要查询的列，那么没必要再回到表里查询数据行了。
   覆盖索引是非常有用的工具，可以极大地提高性能。



### 索引选择策略

​	在网上很多博客都会说，尽量避免使用非等值判断，如 != ，IS NOT NULL， NOT IN 等，因为这样会使索引查询无效。那么为什么非等值判断就会使索引查询无效呢？非等值判断一定会使索引查询无效吗？这个问题很值得讨论和思考，因为它会让你弄懂MySQL索引真正的选择策略。

#### IS NOT NULL 不使用索引吗

​	如果我们对列值进行NULL 值判断，那么通常该列没有设置非空约束。我们分为两种情况讨论，有非空约束和没有非空约束的情况。下面是我多次测试的结果。

情况一（索引列没有非空约束）：

**非覆盖索引查询**

​	非空数据占比低于约10%的时候，判断 is not null 会使用索引，而 is null 会全表扫描；

​	非空数据占比高于约20%的时候，判断 is null 会使用索引, 而 is not null 则是全表扫描；

​	非空数据占比在10%-20%之间的时候, is null 和 is not null 都会使用索引；

**覆盖索引查询**

​	无论非空数据占比是多少，判断 is null 和 is not null 都会使用索引；



情况二（索引列有非空约束）：

既然有非空约束，那么该列就不会有空值，非空数据占比是100%；

**非覆盖索引查询**

​	判断 is null 会直接返回空集，既不会查询索引，也不会查询表；（因为非空约束和 is null 是互斥的两种情况）

​	判断  is not null  会进行全表扫描，同样不会使用索引；

**覆盖索引查询**

​	判断 is null 会直接返回空集，既不会查询索引，也不会查询表；

​	判断 is not null  会进行全索引扫描；（ref : index）

结论:

​	通常情况下，设置索引的列往往都是有值的，而且非空数据的占比很大，所以几乎所有开发者说 is not null 不会使用索引，其实按照这种规范去开发没什么大问题，只不过原理还是需要知晓的， **is null 和 is not null 到底用不用索引，其实没有这么绝对！ mysql优化器会判断操作索引和操作表哪个代价小一些，然后再做出相应的查询策略。**

​	使用覆盖索引查询的情况下, is null 和 is not null 都会使用索引, 此时和非空数据的占比无关;


#### != 不使用索引吗

​	上面用到 **非空数据占比** 这个词，在判断 is null 时，NULL 值就是满足条件的数据；在判断 is not null 时，非 NULL 值就是满足条件的数据，满足条件的数据量除以表的总记录数就是**满足条件的数据占比**。



**等值查询：( = )**
	满足条件的数据占比低于约90%时，使用索引查询；

​	如果满足条件的数据超过90%，那么使用索引后再回表查询，效率反而不高，所以这种情况MySQL不使用索引，直接全表扫描；

**不等于查询：( != )**
	满足条件的数据占比低于约20%时，使用索引查询；如果满足条件的数据超过20%， 则不会使用索引；

​	而当不满足等值条件查询的数据占比在10%-20%之间时,两种查询都会使用索引;

**结论:**

​	可以看出，MySQL这么设计符合二八定律原则。通常情况下， 等值查询返回的结果集占比不会超过80%，所以通常等值查询会使索引生效；
​	而当我们写不等于查询时， 如果查询返回的结果集占比超过20%，那么不等于查询会使索引查询无效；

​	经过分析和测试，我们知道，无论是等值查询还是不等于查询， 都不能单纯的说它走索引还是不走索引， mysql 根据是否为等值查询和满足条件的数据占比来选择合适的查询策略。



#### 覆盖索引查询一定生效吗

1. 限制索引长度的情况，覆盖索引无效;
2. 索引列参与表达式运算，不仅覆盖索引无效，索引查询也会无效;



## 6.5 索引方式（数据结构）

### B-Tree 索引

​	B-Tree 索引的列值是按顺序存储的，并且每一个叶子到根的距离相同。

#### 磁盘IO与预读

1. 磁盘IO的代价是很高的, 一次磁盘io （机械硬盘）的耗时会在 5-10 ms 之间。 
2. 根据局部性原理, 磁盘不仅读取目标数据,也会顺带把相邻数据一并读进内存. 每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。

#### 索引的数据结构(B+树)

​	什么样的数据结构才能支持数据库索引这样的特性，其实很简单，那就是：**每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级**。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。

​	注：在数据结构中B-树和B+树是不同的数据结构，但在数据库索引这里提的B-树就是数据结构中的B+树。

**B+树**



<img src="https://gitee.com/Jackpotsss/pic_go/raw/master/img/image-20200211220433208.png" alt="image-20200211220433208" style="zoom:80%;" />

​	如上图，是一棵B+树，关于b+树的定义可以参见相关资料，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

**B+树的查找过程**

​	如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短，相比磁盘的IO，可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，**3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的**，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

**B+树性质**

​	1. 通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么**b+树要求把真实的数据放到叶子节点而不是内层节点**，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

​	2. 当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即**索引的最左匹配特性**。



#### 聚簇索引

- **聚簇索引并不是一种单独的索引类型，而是一种数据存储方式；**
- **一个InnoDB表有且只有一个聚簇索引；**
- **MySQL中的聚簇索引不能手动指定；**

​	InnoDB 使用的就是聚簇索引，聚簇索引实际上是在一个数据结构（B+树）中同时保存了索引项和数据行。术语“聚簇”表示的就是数据行和相邻的键值紧凑的存储在一起，即表数据和索引数据存储在同一个文件中。

​	因为无法把数据行同时存放在两个不同的地方，所以一个表只能有一个聚簇索引。



聚簇索引的选择：

1. 默认情况下，InnoDB 通过主键聚集数据，即主键索引就是聚簇索引；
2. 如果没有定义主键，InnoDB 会选择一个非空唯一的索引作为聚簇索引；
3. 如果上面两条都不满足，InnoDB 会隐式定义一个主键来作为聚簇索引；

怎么聚集数据？

1. 非叶子节点只包含部分用于检索数据的索引项；
2. 叶子节点包含了全部索引项，每个索引项指向一条行数据；



B-Tree 索引分为两种：

1. 聚簇索引
2. 辅助索引（二级索引）



<img src="https://gitee.com/Jackpotsss/pic_go/raw/master/img/image-20200620141347370.png?raw=true" alt="image-20200317082644072" style="zoom: 80%;" />



​	为什么辅助索引又叫二级索引呢？**因为通过辅助索引访问表数据需要两次索引查找，而不是一次。二级索引叶子节点保存的不是指向行的物理位置指针，而是行的主键值。**

​	这意味着通过二级索引查找行数据，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据主键值去聚簇索引中查找对应的行。这里是两次B-Tree查找而不是一次！不过InnoDB的自适应哈希索引可以减少这样的重复工作。



<img src="https://gitee.com/Jackpotsss/pic_go/raw/master/img/image-20200317082644072.png" alt="image-20200317082644072" style="zoom: 80%;" />



​	那么问题来了，为什么InnoDB在主键索引树的叶子节点存储了具体数据，而在二级索引树上却不存储具体数据，而是非要多此一举找到主键，再在主键索引树找到对应的数据呢？

​	其实很简单，因为InnoDB需要**节省存储空间**。

​	一个表里可能有很多个索引，InnoDB都会为每个加了索引的字段生成索引树，如果每个字段的索引树都存储了具体的数据，那么这个表的索引数据文件就会非常巨大（数据极度冗余了）。所以从节约磁盘空间的角度来说，真的没有必要每个字段索引树都存具体数据，在牺牲较少的查询性能下节省了巨大的磁盘空间，这是非常值得的。



InnoDB 创建表后生成的文件有：

- frm: 存储表结构数据 ;
- idb: 表数据 + 索引数据 ;



**总结**

​	**InnoDB表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。二级索引的叶子节点包含主键列值（二级索引的叶子节点保存了对应行的主键值），所以如果主键列很大的话，其他的所有索引都会很大。因此，主键应当尽可能的小。**



### 哈希索引

​	B-Tree索引是按照数据大小顺序进行存储的，所以很适合范围查找。

​	而哈希索引不是按顺序存储的，哈希索引虽然可以做到快速检索数据，但是没有办法做到高效的范围查找，所以哈希索引不适合作为MySQL索引底层的数据结构。

<img src="https://gitee.com/Jackpotsss/pic_go/raw/master/img/image-20200317081955987.png?raw=true" alt="image-20200317082644072" style="zoom: 33%;" />



## 6.6 小结

​	从数据冗余存储的方面分析，一个应用系统的**缓存和索引**的设计都属于数据的冗余存储，主要目的都是为了提高系统的响应速度。

​	把磁盘中的数据读取到缓存中存储一份，是因为内存的读写速度远大于磁盘，所以缓存中的这部分冗余数据就加快了系统的响应速度。而把经常查询的数据设计为索引，索引文件中冗余这部分数据是按照特定的数据结构进行组织并存储的，因为高效的数据结构，所以读取速度非常快，从而加快系统响应速度。

​	**同样是冗余存储，缓存利用高效的硬件条件，索引利用高效的数据结构。**但无论是引入缓存还是索引，提升效率的同时，也会带来相应的问题，如引入缓存带来的数据一致性问题、缓存击穿、缓存雪崩、缓存穿透，引入索引会占用更多的磁盘空间，降低数据插入速度等，这些都是工程师需要考虑和解决的问题。



